1. namespace    1_namespace.cc
	命名空间可以包含命名空间，需要使用子命名空间需要引用它，如果它与父空间或其它空间右成员冲突，需要知名空间名称。

2. C++对C语言的增强
	1.C语言在BSS段定义两个相同名称的变量是可以编译通过的
	  C++不可以
	2.C语言结构体声明变量是需要带struct 或使用typedef
	  C++不需要，C++把struct当class。
	3.C语言函数可以不署名返回类型，默认int。
	  C++,函数必须指定返回类型
	4.C语言对无参数函数，传递给它参数，编译不会报错，且运行正常。但对于有参数的函数，传递多余的参数，编译会报错。
	  C++对参数个数会检验
	5.bool关键字
		C, 0:非，非0：真
		C++,0和非0依旧可以表示真假，新增bool类型，bool类型，true，false两个赋值。 bool 是一个字节。

3, 三目运算的加强
	在C中三目运算符返回变量的值
	在C++中返回的是变量的引用。

4，const增强
  C:
	const int a   :虽然是只读，但可以通过指针指向a，修改指针变量  这个a是变量，不能当数组的容量标志， int arr[a] 是错的
	int const a
	以上等价

	const int *a  : a指向的地址内存内的内容不可修改，但a可以指向其它地址
	int* const a  : a指向的地址不可改变，但内存地址内的值可以修改。

  C++:
	const int a = 10;   a是真正常量, 编译器将这样的常量放入符号表内,在使用a时，直接将a替换为值，类似宏。 int arr[a] 是可以的。
	int *p = (int*)&a;  如果对一个常量取地址，编译器会临时开辟一个空间，让这个指针存放临时空间的地址。也就是*p指向一个匿名的隐藏内存，修改*p，是修改这块内存的内容。

5，枚举的增强
	C语言 枚举的弊端，enum内可以包含很多项，但在实际使用时可以用值代替，对阅读代码造成困难。
		enum {
			a = 0,
			b
		}
		enum s = 0;
		if(s == 0) {}

	C++   枚举变量想赋值，不能通过值赋值.
		enum s = 0;//error
		enum s = a; //right

6, 引用
	int &a = b;  //a是b的引用
	引用不像指针一样可以修改指向，它是a的引用就一直是，它就是a。
	引用声明必须初始化,且引用可以指向引用.
	int a = 20;
	int b = 30;
	int &re = a;
	rc = b;// 这里相当与将b的30赋值给了a，也就是re。

	优势：
		1，如果引用作为参数，相当于指针变量做参数
			int a = 10; void change(int* a) { *a=10;}  change(&a);
			int a = 10; void change(int &a) { a = 10; } change(a);

引用的本质是： 引用在C++中的内部实现了一个指针常量,且引用与类型指针占空间大小一样。

7,常量指针
	int a = 10;  在栈区
	int arr[10];  arr是一个常量指针，在常量区。10个int的数组在栈区。
	int &b = a;  等价 int* const b = &a;   *b在常量区.

8,引用作为函数返回值
	int& geta(){
		int a = 10;
		return a;
	}
	void main(){
		int a = 0;
		a = geta();  此处调用函数时，返回的是a的引用的值，也就是10，所以main::a最后被返回的是10.
		int &ra = geta(); //ra变成局部变量的a，局部变量被销毁，这个引用就会出问题。所以返回类型为引用的函数不能用引用变量接受返回值。
	}

9,指针引用
	指针：
		void getmem(char** p){
			*p = (char*)malloc(10);
		}
	指针引用:
		void getmem(char* &p){
			p = (char*)malloc(10);
		}

10,const引用
	const int a = 10;
	int& ra = a; //error
	const int& ra = a; ok

11,内联函数
	inline函数是编译器对函数进行类似宏定义(预处理器)的展开，但会对参数进行类型检验。
	函数体不能太大

12,参数的默认参数和占位参数
	默认参数就是给函数的参数一个默认值，如果调用函数时没有给这个参数传参，则用默认值，如果有的参数有默认值，有的没有，则有默认值的参数写在参数列表最后面。

	亚元: void test(int, int),两个占位参数，调用时，必须给这两个参数传参。

13,函数重载
	函数名相同，函数列表不同，返回值类型可以不同，则两个函数互为重载函数

	参数列表：参数个数，参数类型，参数顺序

	但如果其中一个函数和另一个函数的的函数列表内不相同的项存在默认值，会在函数调用是出现歧义。不同想是占位参数是可以的,但占位参数不能有默认值。

	在执行重载函数时，如果参数没有严格匹配的参数类型，则会做隐士转换后调用可匹配的函数，如char -> int,  float -> double

	int a(int, int)
	int b(int, int)
	这两个函数是同一类的，如果使用函数指针只想他们，则只需要一个函数指针。

	在C中，函数名相同的两个函数会认为是重定义。err
	在C++中，函数名相同，函数列表不同，则这两个函数互为彼此的函数重载.
	
14,函数指针与函数重载

20 构造函数和析构函数
	在类创建对象时，会自动调用类的构造函数和析构函数，构造是可以重载的，析构不可以.

21. 默认无参构造函数
	在声明类变量时，没有给变量进行初始化，则变量会调用类的无参构造函数.如果提供了有参构造，则会覆盖无参构造，如果需要无参构造需要显示提供。

22. 拷贝构造函数
	拷贝构造函数需要注意的是函数的参数需是类的引用变量。且如果类的成员变量是private的，在调用引用变量的成员时，可以直接访问成员变量。同类无私处。

23 类中默认函数的隐藏条件
	类中出现显示的无参构造，显示有参，显示拷贝构造，则无参的构造函数就会消失
	没有提供显示拷贝，就会有默认的拷贝构造。

24 析构顺序
	先构造出的对象，后被析构.
	
25 匿名类对象
	当函数返回一个类对象，但函数外没有变量接收它，称它为匿名对象，这个变量不会被使用，（找不到），编译器会直接将这个匿名对象回收，而不是等待整个函数执行完比在回收。回收过程匿名比那辆也会调用析够.
	在函数return类对象时，会触发函数内类对象对临时变量的拷贝构造，但在上层函数内，没有变量接受匿名变量，则会马上调用类的析构函数，将匿名变量销毁。
	如果上层函数内有类对象接受函数返回的类变量，则不会出发上层函数内类对象的拷贝构造，而是将匿名对象的命名。 有类对象名称就可以进行访问，按合理的顺序析构。  dog d2 = func(){return d2}
	另一种有接受的情况  dog d2; d2 = func(){  return d1 }  这里出发的是d2的操作符重载函数; 然后析够匿名对象。

26 深拷贝与浅拷贝
	如果类中有变量的值保存在堆上时会有深拷贝与浅拷贝的区别。
	浅拷贝直接使用已知类对象内指针指向内存地址赋值给新的类对象的指针变量
	深拷贝，新类变量的指针成员新开辟一块内存，将已知类对象的指针对象指向的内存里的内容拷贝到新开辟的内存中。

27 构造函数的初始化列表
	class A {};
	class B {
		public :
			如何构造呢？
			B(A &a1, A &a2) : m_a1(a1), m_a2(a2) //此处会调用A的构造函数
			{

			}
		private :
			A m_a1;
			A m_a2;
	}
